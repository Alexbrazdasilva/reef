<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<title>Reef.js</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<!-- stylesheets -->
		<style type="text/css">
			/**
			 * Add box sizing to everything
			 * @link http://www.paulirish.com/2012/box-sizing-border-box-ftw/
			 */
			*,
			*:before,
			*:after {
				box-sizing: border-box;
			}

			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
				font-size: 112.5%;
				margin-left: auto;
				margin-right: auto;
				max-width: 40em;
				width: 88%;
			}

			/**
			 * 1. Add the correct box sizing in Firefox.
			 * 2. Show the overflow in Edge and IE.
			 */
			hr {
				border: 0;
				border-top: 1px solid #e5e5e5;
				border-bottom: 0 solid transparent;
				box-sizing: content-box; /* 1 */
				margin: 2em auto;
				overflow: visible; /* 2 */
			}

			/**
			 * Syntax Highlighting
			 */
			code,
			kbd,
			pre,
			samp {
				font-family: Menlo, Monaco, "Courier New", monospace;
				font-size: 0.875em;
			}

			code {
				color: #dd1144;
				padding: 0.25em;
				word-wrap: break-word;
			}

			pre {
				background-color: #f7f7f7;
				display: block;
				line-height: 1.5;
				margin-bottom: 1.5625em;
				overflow: auto;
				padding: 0.8125em;
				-moz-tab-size: 4;
				-o-tab-size: 4;
				tab-size: 4;
				white-space: pre-wrap;
				word-break: break-all;
			}

			pre code {
				background-color: transparent;
				border: 0;
				color: inherit;
				font-size: 1em;
				padding: 0;
			}

			/* http://prismjs.com/download.html?themes=prism&languages=clike+javascript */
			/**
			 * prism.js default theme for JavaScript, CSS and HTML
			 * Based on dabblet (http://dabblet.com)
			 * @author Lea Verou
			 */
			.token.comment,
			.token.prolog,
			.token.doctype,
			.token.cdata {
				color: slategray;
			}

			.token.punctuation {
				color: #999;
			}

			.namespace {
				opacity: .7;
			}

			.token.property,
			.token.tag,
			.token.boolean,
			.token.number,
			.token.constant,
			.token.symbol,
			.token.deleted {
				color: #905;
			}

			.token.selector,
			.token.attr-name,
			.token.string,
			.token.char,
			.token.builtin,
			.token.inserted {
				color: #690;
			}

			.token.operator,
			.token.entity,
			.token.url,
			.language-css .token.string,
			.style .token.string {
				color: #a67f59;
				background: hsla(0, 0%, 100%, .5);
			}

			.token.atrule,
			.token.attr-value,
			.token.keyword {
				color: #07a;
			}

			.token.function {
				color: #DD4A68;
			}

			.token.regex,
			.token.important,
			.token.variable {
				color: #e90;
			}

			.token.important,
			.token.bold {
				font-weight: bold;
			}
			.token.italic {
				font-style: italic;
			}

			.token.entity {
				cursor: help;
			}
		</style>

		<!-- Javascript -->
		<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>
		<script src="dist/reef.min.js"></script>
	</head>

	<body>

		<main id="top">

			<nav>
				<h1>Reef.js Demos</h1>
				<p><a href="https://github.com/cferdinandi/reef">GitHub & Docs</a></p>
				<div id="toc"></div>
				<hr>
			</nav>

			<section>
<h2>Clock</h2>

<div id="clock"></div>

<script class="code-sample">
// Markup:
// &lt;div id="clock"&gt;&lt;/div&gt;

// Create the clock component
var clock = new Reef('#clock', {
    data: {
        time: new Date().toLocaleTimeString()
    },
    template: function (props) {
        return '<strong>The time is:</strong> <span> ' + props.time + '</span>';
    }
});

// Render the clock
clock.render();

// Update the clock once a second
window.setInterval(function () {
    clock.data.time = new Date().toLocaleTimeString();
    clock.render();
}, 1000);
</script>
			</section>
		</main>

		<script>
			// Table of Contents
			var toc = function () {

				'use strict';

				// Variables
				var headers = document.querySelectorAll('h2');
				var table = document.querySelector('#toc');
				var contents = '';
				if (!toc || headers.length < 1) return;

				// Create ToC
				Array.from(headers).forEach(function (h2) {
					var id = h2.textContent.replace(' ', '-').replace('\'', '-');
					contents += '<li><a href="#' + id + '">' + h2.textContent + '</a></li>';
					h2.id = id;
				});

				table.innerHTML = '<strong>Demos</strong><ol>' + contents + '</ol>';

			};

			// Code Samples
			var codeSamples = function () {

				'use strict';

				// Variables
				var codes = document.querySelectorAll('.code-sample');
				if (codes.length < 1) return;

				// Add code samples to DOM
				Array.from(codes).forEach(function (code) {
					var pre = document.createElement('pre');
					pre.className = 'lang-js';
					pre.innerHTML = '<code>' + code.innerHTML.trim() + '</code>';
					code.after(pre);
				});

			};

			// Run helpers
			toc();
			codeSamples();

			// Syntax Highlighting
			/* http://prismjs.com/download.html?themes=prism&languages=clike+javascript */
			var _self = (typeof window !== 'undefined')
				? window   // if in browser
				: (
					(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
					? self // if in worker
					: {}   // if in node js
				);

			/**
			 * Prism: Lightweight, robust, elegant syntax highlighting
			 * MIT license http://www.opensource.org/licenses/mit-license.php/
			 * @author Lea Verou http://lea.verou.me
			 */

			var Prism = (function(){

			// Private helper vars
			var lang = /\blang(?:uage)?-(\w+)\b/i;
			var uniqueId = 0;

			var _ = _self.Prism = {
				manual: _self.Prism && _self.Prism.manual,
				util: {
					encode: function (tokens) {
						if (tokens instanceof Token) {
							return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
						} else if (_.util.type(tokens) === 'Array') {
							return tokens.map(_.util.encode);
						} else {
							return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
						}
					},

					type: function (o) {
						return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
					},

					objId: function (obj) {
						if (!obj['__id']) {
							Object.defineProperty(obj, '__id', { value: ++uniqueId });
						}
						return obj['__id'];
					},

					// Deep clone a language definition (e.g. to extend it)
					clone: function (o) {
						var type = _.util.type(o);

						switch (type) {
							case 'Object':
								var clone = {};

								for (var key in o) {
									if (o.hasOwnProperty(key)) {
										clone[key] = _.util.clone(o[key]);
									}
								}

								return clone;

							case 'Array':
								// Check for existence for IE8
								return o.map && o.map(function(v) { return _.util.clone(v); });
						}

						return o;
					}
				},

				languages: {
					extend: function (id, redef) {
						var lang = _.util.clone(_.languages[id]);

						for (var key in redef) {
							lang[key] = redef[key];
						}

						return lang;
					},

					/**
					 * Insert a token before another token in a language literal
					 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
					 * we cannot just provide an object, we need anobject and a key.
					 * @param inside The key (or language id) of the parent
					 * @param before The key to insert before. If not provided, the function appends instead.
					 * @param insert Object with the key/value pairs to insert
					 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
					 */
					insertBefore: function (inside, before, insert, root) {
						root = root || _.languages;
						var grammar = root[inside];

						if (arguments.length == 2) {
							insert = arguments[1];

							for (var newToken in insert) {
								if (insert.hasOwnProperty(newToken)) {
									grammar[newToken] = insert[newToken];
								}
							}

							return grammar;
						}

						var ret = {};

						for (var token in grammar) {

							if (grammar.hasOwnProperty(token)) {

								if (token == before) {

									for (var newToken in insert) {

										if (insert.hasOwnProperty(newToken)) {
											ret[newToken] = insert[newToken];
										}
									}
								}

								ret[token] = grammar[token];
							}
						}

						// Update references in other language definitions
						_.languages.DFS(_.languages, function(key, value) {
							if (value === root[inside] && key != inside) {
								this[key] = ret;
							}
						});

						return root[inside] = ret;
					},

					// Traverse a language definition with Depth First Search
					DFS: function(o, callback, type, visited) {
						visited = visited || {};
						for (var i in o) {
							if (o.hasOwnProperty(i)) {
								callback.call(o, i, o[i], type || i);

								if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
									visited[_.util.objId(o[i])] = true;
									_.languages.DFS(o[i], callback, null, visited);
								}
								else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
									visited[_.util.objId(o[i])] = true;
									_.languages.DFS(o[i], callback, i, visited);
								}
							}
						}
					}
				},
				plugins: {},

				highlightAll: function(async, callback) {
					var env = {
						callback: callback,
						selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
					};

					_.hooks.run("before-highlightall", env);

					var elements = env.elements || document.querySelectorAll(env.selector);

					for (var i=0, element; element = elements[i++];) {
						_.highlightElement(element, async === true, env.callback);
					}
				},

				highlightElement: function(element, async, callback) {
					// Find language
					var language, grammar, parent = element;

					while (parent && !lang.test(parent.className)) {
						parent = parent.parentNode;
					}

					if (parent) {
						language = (parent.className.match(lang) || [,''])[1].toLowerCase();
						grammar = _.languages[language];
					}

					// Set language on the element, if not present
					element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

					// Set language on the parent, for styling
					parent = element.parentNode;

					if (/pre/i.test(parent.nodeName)) {
						parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
					}

					var code = element.textContent;

					var env = {
						element: element,
						language: language,
						grammar: grammar,
						code: code
					};

					_.hooks.run('before-sanity-check', env);

					if (!env.code || !env.grammar) {
						if (env.code) {
							env.element.textContent = env.code;
						}
						_.hooks.run('complete', env);
						return;
					}

					_.hooks.run('before-highlight', env);

					if (async && _self.Worker) {
						var worker = new Worker(_.filename);

						worker.onmessage = function(evt) {
							env.highlightedCode = evt.data;

							_.hooks.run('before-insert', env);

							env.element.innerHTML = env.highlightedCode;

							callback && callback.call(env.element);
							_.hooks.run('after-highlight', env);
							_.hooks.run('complete', env);
						};

						worker.postMessage(JSON.stringify({
							language: env.language,
							code: env.code,
							immediateClose: true
						}));
					}
					else {
						env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

						_.hooks.run('before-insert', env);

						env.element.innerHTML = env.highlightedCode;

						callback && callback.call(element);

						_.hooks.run('after-highlight', env);
						_.hooks.run('complete', env);
					}
				},

				highlight: function (text, grammar, language) {
					var tokens = _.tokenize(text, grammar);
					return Token.stringify(_.util.encode(tokens), language);
				},

				tokenize: function(text, grammar, language) {
					var Token = _.Token;

					var strarr = [text];

					var rest = grammar.rest;

					if (rest) {
						for (var token in rest) {
							grammar[token] = rest[token];
						}

						delete grammar.rest;
					}

					tokenloop: for (var token in grammar) {
						if(!grammar.hasOwnProperty(token) || !grammar[token]) {
							continue;
						}

						var patterns = grammar[token];
						patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

						for (var j = 0; j < patterns.length; ++j) {
							var pattern = patterns[j],
								inside = pattern.inside,
								lookbehind = !!pattern.lookbehind,
								greedy = !!pattern.greedy,
								lookbehindLength = 0,
								alias = pattern.alias;

							if (greedy && !pattern.pattern.global) {
								// Without the global flag, lastIndex won't work
								var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
								pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
							}

							pattern = pattern.pattern || pattern;

							// Don’t cache length as it changes during the loop
							for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

								var str = strarr[i];

								if (strarr.length > text.length) {
									// Something went terribly wrong, ABORT, ABORT!
									break tokenloop;
								}

								if (str instanceof Token) {
									continue;
								}

								pattern.lastIndex = 0;

								var match = pattern.exec(str),
								    delNum = 1;

								// Greedy patterns can override/remove up to two previously matched tokens
								if (!match && greedy && i != strarr.length - 1) {
									pattern.lastIndex = pos;
									match = pattern.exec(text);
									if (!match) {
										break;
									}

									var from = match.index + (lookbehind ? match[1].length : 0),
									    to = match.index + match[0].length,
									    k = i,
									    p = pos;

									for (var len = strarr.length; k < len && p < to; ++k) {
										p += strarr[k].length;
										// Move the index i to the element in strarr that is closest to from
										if (from >= p) {
											++i;
											pos = p;
										}
									}

									/*
									 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
									 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
									 */
									if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
										continue;
									}

									// Number of tokens to delete and replace with the new match
									delNum = k - i;
									str = text.slice(pos, p);
									match.index -= pos;
								}

								if (!match) {
									continue;
								}

								if(lookbehind) {
									lookbehindLength = match[1].length;
								}

								var from = match.index + lookbehindLength,
								    match = match[0].slice(lookbehindLength),
								    to = from + match.length,
								    before = str.slice(0, from),
								    after = str.slice(to);

								var args = [i, delNum];

								if (before) {
									args.push(before);
								}

								var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

								args.push(wrapped);

								if (after) {
									args.push(after);
								}

								Array.prototype.splice.apply(strarr, args);
							}
						}
					}

					return strarr;
				},

				hooks: {
					all: {},

					add: function (name, callback) {
						var hooks = _.hooks.all;

						hooks[name] = hooks[name] || [];

						hooks[name].push(callback);
					},

					run: function (name, env) {
						var callbacks = _.hooks.all[name];

						if (!callbacks || !callbacks.length) {
							return;
						}

						for (var i=0, callback; callback = callbacks[i++];) {
							callback(env);
						}
					}
				}
			};

			var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
				this.type = type;
				this.content = content;
				this.alias = alias;
				// Copy of the full string this token was created from
				this.length = (matchedStr || "").length|0;
				this.greedy = !!greedy;
			};

			Token.stringify = function(o, language, parent) {
				if (typeof o == 'string') {
					return o;
				}

				if (_.util.type(o) === 'Array') {
					return o.map(function(element) {
						return Token.stringify(element, language, o);
					}).join('');
				}

				var env = {
					type: o.type,
					content: Token.stringify(o.content, language, parent),
					tag: 'span',
					classes: ['token', o.type],
					attributes: {},
					language: language,
					parent: parent
				};

				if (env.type == 'comment') {
					env.attributes['spellcheck'] = 'true';
				}

				if (o.alias) {
					var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
					Array.prototype.push.apply(env.classes, aliases);
				}

				_.hooks.run('wrap', env);

				var attributes = Object.keys(env.attributes).map(function(name) {
					return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
				}).join(' ');

				return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

			};

			if (!_self.document) {
				if (!_self.addEventListener) {
					// in Node.js
					return _self.Prism;
				}
			 	// In worker
				_self.addEventListener('message', function(evt) {
					var message = JSON.parse(evt.data),
					    lang = message.language,
					    code = message.code,
					    immediateClose = message.immediateClose;

					_self.postMessage(_.highlight(code, _.languages[lang], lang));
					if (immediateClose) {
						_self.close();
					}
				}, false);

				return _self.Prism;
			}

			//Get current script and highlight
			var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

			if (script) {
				_.filename = script.src;

				if (document.addEventListener && !_.manual && !script.hasAttribute('data-manual')) {
					if(document.readyState !== "loading") {
						if (window.requestAnimationFrame) {
							window.requestAnimationFrame(_.highlightAll);
						} else {
							window.setTimeout(_.highlightAll, 16);
						}
					}
					else {
						document.addEventListener('DOMContentLoaded', _.highlightAll);
					}
				}
			}

			return _self.Prism;

			})();

			if (typeof module !== 'undefined' && module.exports) {
				module.exports = Prism;
			}

			// hack for components to work correctly in node.js
			if (typeof global !== 'undefined') {
				global.Prism = Prism;
			}
			;
			Prism.languages.clike = {
				'comment': [
					{
						pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
						lookbehind: true
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true
					}
				],
				'string': {
					pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				'class-name': {
					pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
					lookbehind: true,
					inside: {
						punctuation: /(\.|\\)/
					}
				},
				'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
				'boolean': /\b(true|false)\b/,
				'function': /[a-z0-9_]+(?=\()/i,
				'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
				'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
				'punctuation': /[{}[\];(),.:]/
			};

			Prism.languages.javascript = Prism.languages.extend('clike', {
				'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
				'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
				// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
				'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
				'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
			});

			Prism.languages.insertBefore('javascript', 'keyword', {
				'regex': {
					pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
					lookbehind: true,
					greedy: true
				}
			});

			Prism.languages.insertBefore('javascript', 'string', {
				'template-string': {
					pattern: /`(?:\\\\|\\?[^\\])*?`/,
					greedy: true,
					inside: {
						'interpolation': {
							pattern: /\$\{[^}]+\}/,
							inside: {
								'interpolation-punctuation': {
									pattern: /^\$\{|\}$/,
									alias: 'punctuation'
								},
								rest: Prism.languages.javascript
							}
						},
						'string': /[\s\S]+/
					}
				}
			});

			if (Prism.languages.markup) {
				Prism.languages.insertBefore('markup', 'tag', {
					'script': {
						pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
						lookbehind: true,
						inside: Prism.languages.javascript,
						alias: 'language-javascript'
					}
				});
			}

			Prism.languages.js = Prism.languages.javascript;
		</script>
	</body>
</html>